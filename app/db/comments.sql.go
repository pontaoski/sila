// Code generated by sqlc. DO NOT EDIT.
// source: comments.sql

package db

import (
	"context"
	"database/sql"
)

const addComment = `-- name: AddComment :one
INSERT INTO Comments (
    Bug_ID, Author_ID, Comment_Text, Created_At
) VALUES (
    $1, $2, $3, NOW()
)
RETURNING id, comment_text, created_at, edited_at, redacted, bug_id, author_id
`

type AddCommentParams struct {
	BugID       int64          `json:"bug_id"`
	AuthorID    int64          `json:"author_id"`
	CommentText sql.NullString `json:"comment_text"`
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (Comment, error) {
	row := q.queryRow(ctx, q.addCommentStmt, addComment, arg.BugID, arg.AuthorID, arg.CommentText)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.CommentText,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Redacted,
		&i.BugID,
		&i.AuthorID,
	)
	return i, err
}

const editComment = `-- name: EditComment :one
UPDATE Comments
    SET Comment_Text = $2,
        Edited_At = NOW()
    WHERE ID = $1
    RETURNING id, comment_text, created_at, edited_at, redacted, bug_id, author_id
`

type EditCommentParams struct {
	ID          int64          `json:"id"`
	CommentText sql.NullString `json:"comment_text"`
}

func (q *Queries) EditComment(ctx context.Context, arg EditCommentParams) (Comment, error) {
	row := q.queryRow(ctx, q.editCommentStmt, editComment, arg.ID, arg.CommentText)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.CommentText,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Redacted,
		&i.BugID,
		&i.AuthorID,
	)
	return i, err
}

const redactComment = `-- name: RedactComment :exec
UPDATE Comments
SET Redacted = TRUE
`

func (q *Queries) RedactComment(ctx context.Context) error {
	_, err := q.exec(ctx, q.redactCommentStmt, redactComment)
	return err
}
